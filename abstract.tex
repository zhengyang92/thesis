Modern computer architectures are complex, with a wide range of
features that can be leveraged to optimize software performance.
However, efficiently optimizing software for these architectures
remains a challenging task. Traditional optimization techniques,
such as manual optimization by human experts or optimization by
compilers, may not fully exploit the unique features of novel
architectures, leading to suboptimal performance.

Program synthesis is a promising approach to address this challenge.
At its core, program synthesis searches for programs that meet a
specified set of requirements. Recent advances in SMT solvers and
increased computation power have made program synthesis a viable
choice for code generation. Program synthesis can generate code
specifically tailored to the target architecture, leveraging
domain-specific knowledge and advanced search techniques to create
highly optimized code.

The overall goal of this dissertation is to develop program
synthesizers that efficiently optimize software for emerging
architectures. The thesis statement of my dissertation is that program
synthesis can be used to generate highly optimized code for novel
architectures, outperforming traditional optimization techniques. To
achieve this goal, I develop program synthesizers that can
generate optimized code for specific architectures, leveraging
domain-specific knowledge and advanced search techniques. I
evaluate the effectiveness of these synthesizers by comparing the
generated code with manually optimized code and code generated by
traditional compilers. The results of this research demonstrate
the potential of program synthesis as a powerful tool for optimizing
software for emerging architectures.

I present Minotaur, a superoptimizer that uses program synthesis
to optimize LLVM IR code. Minotaur extracts program slices from LLVM IR
code, and uses an SMT solver to find optimized versions of these slices.
Minotaur is designed to work within the LLVM optimization pipeline, and
can be used to discover new optimizations that are missed by traditional
compilers.

We  present SCCL, a program synthesizer that optimizes collective
algorithms for parallel computation. SCCL uses domain-specific knowledge
about collective algorithms to generate highly optimized code for
specific architectures. SCCL is designed to work with MPI and OpenMP
applications, and can be used to improve the performance of parallel
applications on novel architectures.




\begin{comment}


The rapid evolution of computer hardware introduces novel
architectures that demand efficient utilization for optimal performance.
These innovative architectures enhance the capabilities of processors,
enabling them to perform more complex tasks and improve overall efficiency.
%
For example, GPUs achieve high performance by utilizing specialized hardware
features specifically designed to optimize parallel processing and
computational tasks, and the Vector Processing Units (VPUs) within CPUs
are designed to handle vector operations efficiently,
making them particularly well-suited to applications
 such as video encoding, compression,
and image processing applications.
%
These cutting-edge new architectures are gathering significant interest
from software developers and researchers.

Programs running on top of these new architectures are either
optimized manually by human experts, or optimized by optimizing compilers.
However, both approaches struggle to keep pace
with innovations in architecture, as
the features in those new architectures may not be fully supported
or understood by existing compilers and experts;
%
additionally, optimizing compilers and experts usually rely on heuristics
to determine the best optimization strategies.
%
These heuristics might not be tailored to the specific features
of novel architectures, leading to suboptimal performance.
%
Consequently, efficiently optimizing programs for new architectures remains
a challenging endeavor.

Program synthesis is a promising approach to address the challenge.
%
At its core, program synthesis searches for programs
that meet a specified set of requirements.
%
Nowadays, the advances in SMT solvers and increased computation power
have made program synthesis a more viable choice for code generation.
%
There are several reasons why program synthesis can help address the challenge:

\begin{itemize}
\item \textbf{Adaptability}: Unlike optimizing compilers or human experts,
program synthesis can generate code specifically tailored to the
target architecture.
%minotaur
For example, in superoptimizers,
once the semantics of an instruction is fed into the refinement checker,
it can automatically generate code that takes advantage of the instruction.

\item \textbf{Domain-specific optimizations}: Program synthesis can take
into account the unique characteristics of a specific domain,
such as collective algorithms in parallel computation,
to create highly optimized code.
%sccl
This domain-aware optimization further enhances the
performance of applications on new architectures.

\item \textbf{Continuous improvement}: As an architecture evolves and
new features are introduced, program synthesis techniques can be updated
to incorporate these advancements, ensuring that the generated code remains
optimized over time.
\end{itemize}

This proposal focuses on developing program synthesizers
that aim to efficiently optimize software for emerging architectures.
The thesis statement of my dissertation is

\end{comment}